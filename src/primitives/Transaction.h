/*
 * transaction.h defines the structure of the transaction section of a block.
 *
 *  Created on: Dec 11, 2017
 *  Author: Nick Williams
 *
 *  **Transaction Structure**
 *  oper - coin operation (one of create, modify, exchange, delete)
 *  xfer - array of participants
 *  nonce - generated by wallet
 *  sig - generated by wallet
 *
 *  xfer params:
 *  addr - wallet address
 *  type - the coin type
 *  amount - postive implies giving, negative implies taking, 0 implies neither
 *  delay - seconds until this Transfer is considered final
 *
 */

#ifndef DEVCASH_PRIMITIVES_TRANSACTION_H
#define DEVCASH_PRIMITIVES_TRANSACTION_H

#include <string>
#include <vector>
#include <stdint.h>

#include "Transfer.h"
#include "Summary.h"
#include "Validation.h"
#include "consensus/KeyRing.h"
#include "consensus/chainstate.h"

using namespace Devcash;

namespace Devcash
{
static const std::string kXFER_COUNT_TAG = "xfer_count";
static const std::string kOPER_TAG = "oper";
static const std::string kXFER_TAG = "xfer";
static const std::string kNONCE_TAG = "nonce";
static const std::string kSIG_TAG = "sig";

enum eOpType : byte {
  Create     = 0,
  Modify     = 1,
  Exchange   = 2,
  Delete     = 3};

class Transaction {
 public:

/** Constructors */
  Transaction() : xfer_count_(0), canonical_(), is_sound_(false) {}
  Transaction(uint64_t xfer_count, bool is_sound)
    : xfer_count_(xfer_count), canonical_(), is_sound_(is_sound) {}
  Transaction(uint64_t xfer_count, std::vector<byte> canonical
    , bool is_sound)
    : xfer_count_(xfer_count), canonical_(canonical), is_sound_(is_sound) {}
  Transaction(const Transaction& other) : xfer_count_(other.xfer_count_)
    , canonical_(other.canonical_), is_sound_(other.is_sound_) {}

  virtual ~Transaction() {}

  /** Comparison Operators */
  friend bool operator==(const Transaction& a, const Transaction& b)
  {
    return a.canonical_ == b.canonical_;
  }

  friend bool operator!=(const Transaction& a, const Transaction& b)
  {
    return a.canonical_ != b.canonical_;
  }

  static size_t MinSize() {
    return 89;
  }

  static size_t EnvelopeSize() {
    return 17;
  }

  /** Returns a canonical bytestring representation of this transaction.
   * @return a canonical bytestring representation of this transaction.
  */
  std::vector<byte> getCanonical() const {
    return canonical_;
  }

  /** Returns the message digest bytestring for this transaction.
   * @return the message digest bytestring for this transaction.
  */
  std::vector<byte> getMessageDigest() const {
    std::vector<byte> md(canonical_.begin()
        , canonical_.begin()+(EnvelopeSize()+Transfer::Size()*xfer_count_));
    return md;
  }

  /** Returns the transaction size in bytes.
   * @return the transaction size in bytes.
  */
  size_t getByteSize() const {
    return(canonical_.size());
  }

  byte getOperation() const {
    return do_getOperation();
  }

  std::vector<Transfer> getTransfers() const {
    return do_getTransfers();
  }

  uint64_t getNonce() const {
    return do_getNonce();
  }

  Signature getSignature() const {
    return do_getSignature();
  }

  bool setIsSound(const KeyRing& keys) {
    return do_setIsSound(keys);
  }

  /** Checks if this transaction is sound, meaning potentially valid.
   *  If any portion of the transaction is invalid,
   *  the entire transaction is also unsound.
   * @params keys a KeyRing that provides keys for signature verification
   * @return true iff the transaction is sound
   * @return false otherwise
   */
  bool isSound(const KeyRing& keys) const {
    return do_isSound(keys);
  }

/** Checks if this transaction is valid with respect to a chain state.
 *  Transactions are atomic, so if any portion of the transaction is invalid,
 *  the entire transaction is also invalid.
 * @params state the chain state to validate against
 * @params keys a KeyRing that provides keys for signature verification
 * @params summary the Summary to update
 * @return true iff the transaction is valid
 * @return false otherwise
 */
  bool isValid(ChainState& state, const KeyRing& keys, Summary& summary) const {
    return false;
  }


/** Returns a JSON string representing this transaction.
 * @return a JSON string representing this transaction.
*/
  std::string getJSON() const {
    return do_getJSON();
  }

 protected:
  uint64_t xfer_count_;
  std::vector<byte> canonical_;
  bool is_sound_ = false;

 private:

  byte do_getOperation() const { return (byte) -1; }

  std::vector<Transfer> do_getTransfers() const
  {
    std::vector<Transfer> out;
    return out;
  }

  uint64_t do_getNonce() const { return 0; }

  Signature do_getSignature() const {
    Signature out;
    return out;
  }

  bool do_setIsSound(const KeyRing& keys) {
    return false;
  }

  bool do_isSound(const KeyRing& keys) const {
    return false;
  }

  bool do_isValid(ChainState& state, const KeyRing& keys, Summary& summary) {
    return false;
  }

  std::string do_getJSON() const {
    return "";
  }
};

} //end namespace Devcash

#endif // DEVCASH_PRIMITIVES_TRANSACTION_H
