// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEVCASHPRIMITIVES_DEVCASH_FBS_H_
#define FLATBUFFERS_GENERATED_DEVCASHPRIMITIVES_DEVCASH_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace Devcash {
namespace fbs {

struct int128;

struct int256;

struct Transfer;
struct TransferT;

struct Transaction;
struct TransactionT;

struct ValidationMap;
struct ValidationMapT;

struct Validation;
struct ValidationT;

struct SummaryItem;
struct SummaryItemT;

struct CoinMap;
struct CoinMapT;

struct Summary;
struct SummaryT;

struct StateMap;
struct StateMapT;

struct ChainState;
struct ChainStateT;

struct TransactionSummaryBlock;
struct TransactionSummaryBlockT;

struct TSVBlock;
struct TSVBlockT;

struct FinalBlock;
struct FinalBlockT;

struct ProposalBlock;
struct ProposalBlockT;

struct UpcomingBlock;
struct UpcomingBlockT;

struct TransactionAnnouncement;
struct TransactionAnnouncementT;

struct UpcomingChain;
struct UpcomingChainT;

struct ProposalChain;
struct ProposalChainT;

struct FinalChain;
struct FinalChainT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) int128 FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t least_sig_word_;
  int64_t most_sig_word_;

 public:
  int128() {
    memset(this, 0, sizeof(int128));
  }
  int128(int64_t _least_sig_word, int64_t _most_sig_word)
      : least_sig_word_(flatbuffers::EndianScalar(_least_sig_word)),
        most_sig_word_(flatbuffers::EndianScalar(_most_sig_word)) {
  }
  int64_t least_sig_word() const {
    return flatbuffers::EndianScalar(least_sig_word_);
  }
  void mutate_least_sig_word(int64_t _least_sig_word) {
    flatbuffers::WriteScalar(&least_sig_word_, _least_sig_word);
  }
  int64_t most_sig_word() const {
    return flatbuffers::EndianScalar(most_sig_word_);
  }
  void mutate_most_sig_word(int64_t _most_sig_word) {
    flatbuffers::WriteScalar(&most_sig_word_, _most_sig_word);
  }
};
FLATBUFFERS_STRUCT_END(int128, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) int256 FLATBUFFERS_FINAL_CLASS {
 private:
  int128 least_sig_int128_;
  int128 most_sig_int128_;

 public:
  int256() {
    memset(this, 0, sizeof(int256));
  }
  int256(const int128 &_least_sig_int128, const int128 &_most_sig_int128)
      : least_sig_int128_(_least_sig_int128),
        most_sig_int128_(_most_sig_int128) {
  }
  const int128 &least_sig_int128() const {
    return least_sig_int128_;
  }
  int128 &mutable_least_sig_int128() {
    return least_sig_int128_;
  }
  const int128 &most_sig_int128() const {
    return most_sig_int128_;
  }
  int128 &mutable_most_sig_int128() {
    return most_sig_int128_;
  }
};
FLATBUFFERS_STRUCT_END(int256, 32);

struct TransferT : public flatbuffers::NativeTable {
  typedef Transfer TableType;
  std::vector<int8_t> addr;
  int64_t amount;
  int64_t coin_index;
  int64_t delay;
  TransferT()
      : amount(0),
        coin_index(0),
        delay(0) {
  }
};

struct Transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransferT NativeTableType;
  enum {
    VT_ADDR = 4,
    VT_AMOUNT = 6,
    VT_COIN_INDEX = 8,
    VT_DELAY = 10
  };
  const flatbuffers::Vector<int8_t> *addr() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  flatbuffers::Vector<int8_t> *mutable_addr() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  int64_t amount() const {
    return GetField<int64_t>(VT_AMOUNT, 0);
  }
  bool mutate_amount(int64_t _amount) {
    return SetField<int64_t>(VT_AMOUNT, _amount, 0);
  }
  int64_t coin_index() const {
    return GetField<int64_t>(VT_COIN_INDEX, 0);
  }
  bool mutate_coin_index(int64_t _coin_index) {
    return SetField<int64_t>(VT_COIN_INDEX, _coin_index, 0);
  }
  int64_t delay() const {
    return GetField<int64_t>(VT_DELAY, 0);
  }
  bool mutate_delay(int64_t _delay) {
    return SetField<int64_t>(VT_DELAY, _delay, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDR) &&
           verifier.Verify(addr()) &&
           VerifyField<int64_t>(verifier, VT_AMOUNT) &&
           VerifyField<int64_t>(verifier, VT_COIN_INDEX) &&
           VerifyField<int64_t>(verifier, VT_DELAY) &&
           verifier.EndTable();
  }
  TransferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transfer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransferT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addr(flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr) {
    fbb_.AddOffset(Transfer::VT_ADDR, addr);
  }
  void add_amount(int64_t amount) {
    fbb_.AddElement<int64_t>(Transfer::VT_AMOUNT, amount, 0);
  }
  void add_coin_index(int64_t coin_index) {
    fbb_.AddElement<int64_t>(Transfer::VT_COIN_INDEX, coin_index, 0);
  }
  void add_delay(int64_t delay) {
    fbb_.AddElement<int64_t>(Transfer::VT_DELAY, delay, 0);
  }
  explicit TransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransferBuilder &operator=(const TransferBuilder &);
  flatbuffers::Offset<Transfer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transfer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transfer> CreateTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr = 0,
    int64_t amount = 0,
    int64_t coin_index = 0,
    int64_t delay = 0) {
  TransferBuilder builder_(_fbb);
  builder_.add_delay(delay);
  builder_.add_coin_index(coin_index);
  builder_.add_amount(amount);
  builder_.add_addr(addr);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transfer> CreateTransferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *addr = nullptr,
    int64_t amount = 0,
    int64_t coin_index = 0,
    int64_t delay = 0) {
  return Devcash::fbs::CreateTransfer(
      _fbb,
      addr ? _fbb.CreateVector<int8_t>(*addr) : 0,
      amount,
      coin_index,
      delay);
}

flatbuffers::Offset<Transfer> CreateTransfer(flatbuffers::FlatBufferBuilder &_fbb, const TransferT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransactionT : public flatbuffers::NativeTable {
  typedef Transaction TableType;
  std::vector<std::unique_ptr<TransferT>> xfers;
  std::vector<int8_t> nonce;
  std::vector<int8_t> sig;
  TransactionT() {
  }
};

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransactionT NativeTableType;
  enum {
    VT_XFERS = 4,
    VT_NONCE = 6,
    VT_SIG = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transfer>> *xfers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transfer>> *>(VT_XFERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Transfer>> *mutable_xfers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Transfer>> *>(VT_XFERS);
  }
  const flatbuffers::Vector<int8_t> *nonce() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NONCE);
  }
  flatbuffers::Vector<int8_t> *mutable_nonce() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NONCE);
  }
  const flatbuffers::Vector<int8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<int8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_SIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XFERS) &&
           verifier.Verify(xfers()) &&
           verifier.VerifyVectorOfTables(xfers()) &&
           VerifyOffset(verifier, VT_NONCE) &&
           verifier.Verify(nonce()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.Verify(sig()) &&
           verifier.EndTable();
  }
  TransactionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransactionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transaction> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xfers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transfer>>> xfers) {
    fbb_.AddOffset(Transaction::VT_XFERS, xfers);
  }
  void add_nonce(flatbuffers::Offset<flatbuffers::Vector<int8_t>> nonce) {
    fbb_.AddOffset(Transaction::VT_NONCE, nonce);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<int8_t>> sig) {
    fbb_.AddOffset(Transaction::VT_SIG, sig);
  }
  explicit TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transaction>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transfer>>> xfers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> nonce = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> sig = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_nonce(nonce);
  builder_.add_xfers(xfers);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transfer>> *xfers = nullptr,
    const std::vector<int8_t> *nonce = nullptr,
    const std::vector<int8_t> *sig = nullptr) {
  return Devcash::fbs::CreateTransaction(
      _fbb,
      xfers ? _fbb.CreateVector<flatbuffers::Offset<Transfer>>(*xfers) : 0,
      nonce ? _fbb.CreateVector<int8_t>(*nonce) : 0,
      sig ? _fbb.CreateVector<int8_t>(*sig) : 0);
}

flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValidationMapT : public flatbuffers::NativeTable {
  typedef ValidationMap TableType;
  std::vector<int8_t> addr;
  std::vector<int8_t> sig;
  ValidationMapT() {
  }
};

struct ValidationMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValidationMapT NativeTableType;
  enum {
    VT_ADDR = 4,
    VT_SIG = 6
  };
  const flatbuffers::Vector<int8_t> *addr() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  flatbuffers::Vector<int8_t> *mutable_addr() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  const flatbuffers::Vector<int8_t> *sig() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SIG);
  }
  flatbuffers::Vector<int8_t> *mutable_sig() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_SIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDR) &&
           verifier.Verify(addr()) &&
           VerifyOffset(verifier, VT_SIG) &&
           verifier.Verify(sig()) &&
           verifier.EndTable();
  }
  ValidationMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValidationMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ValidationMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ValidationMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValidationMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addr(flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr) {
    fbb_.AddOffset(ValidationMap::VT_ADDR, addr);
  }
  void add_sig(flatbuffers::Offset<flatbuffers::Vector<int8_t>> sig) {
    fbb_.AddOffset(ValidationMap::VT_SIG, sig);
  }
  explicit ValidationMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ValidationMapBuilder &operator=(const ValidationMapBuilder &);
  flatbuffers::Offset<ValidationMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ValidationMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<ValidationMap> CreateValidationMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> sig = 0) {
  ValidationMapBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_addr(addr);
  return builder_.Finish();
}

inline flatbuffers::Offset<ValidationMap> CreateValidationMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *addr = nullptr,
    const std::vector<int8_t> *sig = nullptr) {
  return Devcash::fbs::CreateValidationMap(
      _fbb,
      addr ? _fbb.CreateVector<int8_t>(*addr) : 0,
      sig ? _fbb.CreateVector<int8_t>(*sig) : 0);
}

flatbuffers::Offset<ValidationMap> CreateValidationMap(flatbuffers::FlatBufferBuilder &_fbb, const ValidationMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValidationT : public flatbuffers::NativeTable {
  typedef Validation TableType;
  std::vector<std::unique_ptr<ValidationMapT>> summary_map;
  ValidationT() {
  }
};

struct Validation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValidationT NativeTableType;
  enum {
    VT_SUMMARY_MAP = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ValidationMap>> *summary_map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ValidationMap>> *>(VT_SUMMARY_MAP);
  }
  flatbuffers::Vector<flatbuffers::Offset<ValidationMap>> *mutable_summary_map() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ValidationMap>> *>(VT_SUMMARY_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUMMARY_MAP) &&
           verifier.Verify(summary_map()) &&
           verifier.VerifyVectorOfTables(summary_map()) &&
           verifier.EndTable();
  }
  ValidationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValidationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Validation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ValidationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValidationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_summary_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ValidationMap>>> summary_map) {
    fbb_.AddOffset(Validation::VT_SUMMARY_MAP, summary_map);
  }
  explicit ValidationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ValidationBuilder &operator=(const ValidationBuilder &);
  flatbuffers::Offset<Validation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Validation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Validation> CreateValidation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ValidationMap>>> summary_map = 0) {
  ValidationBuilder builder_(_fbb);
  builder_.add_summary_map(summary_map);
  return builder_.Finish();
}

inline flatbuffers::Offset<Validation> CreateValidationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ValidationMap>> *summary_map = nullptr) {
  return Devcash::fbs::CreateValidation(
      _fbb,
      summary_map ? _fbb.CreateVector<flatbuffers::Offset<ValidationMap>>(*summary_map) : 0);
}

flatbuffers::Offset<Validation> CreateValidation(flatbuffers::FlatBufferBuilder &_fbb, const ValidationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SummaryItemT : public flatbuffers::NativeTable {
  typedef SummaryItem TableType;
  int64_t delay;
  int64_t delta;
  SummaryItemT()
      : delay(0),
        delta(0) {
  }
};

struct SummaryItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SummaryItemT NativeTableType;
  enum {
    VT_DELAY = 4,
    VT_DELTA = 6
  };
  int64_t delay() const {
    return GetField<int64_t>(VT_DELAY, 0);
  }
  bool mutate_delay(int64_t _delay) {
    return SetField<int64_t>(VT_DELAY, _delay, 0);
  }
  int64_t delta() const {
    return GetField<int64_t>(VT_DELTA, 0);
  }
  bool mutate_delta(int64_t _delta) {
    return SetField<int64_t>(VT_DELTA, _delta, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DELAY) &&
           VerifyField<int64_t>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
  SummaryItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SummaryItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SummaryItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SummaryItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SummaryItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_delay(int64_t delay) {
    fbb_.AddElement<int64_t>(SummaryItem::VT_DELAY, delay, 0);
  }
  void add_delta(int64_t delta) {
    fbb_.AddElement<int64_t>(SummaryItem::VT_DELTA, delta, 0);
  }
  explicit SummaryItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummaryItemBuilder &operator=(const SummaryItemBuilder &);
  flatbuffers::Offset<SummaryItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummaryItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummaryItem> CreateSummaryItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t delay = 0,
    int64_t delta = 0) {
  SummaryItemBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_delay(delay);
  return builder_.Finish();
}

flatbuffers::Offset<SummaryItem> CreateSummaryItem(flatbuffers::FlatBufferBuilder &_fbb, const SummaryItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CoinMapT : public flatbuffers::NativeTable {
  typedef CoinMap TableType;
  int64_t coin;
  std::unique_ptr<SummaryItemT> summary;
  CoinMapT()
      : coin(0) {
  }
};

struct CoinMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CoinMapT NativeTableType;
  enum {
    VT_COIN = 4,
    VT_SUMMARY = 6
  };
  int64_t coin() const {
    return GetField<int64_t>(VT_COIN, 0);
  }
  bool mutate_coin(int64_t _coin) {
    return SetField<int64_t>(VT_COIN, _coin, 0);
  }
  const SummaryItem *summary() const {
    return GetPointer<const SummaryItem *>(VT_SUMMARY);
  }
  SummaryItem *mutable_summary() {
    return GetPointer<SummaryItem *>(VT_SUMMARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_COIN) &&
           VerifyOffset(verifier, VT_SUMMARY) &&
           verifier.VerifyTable(summary()) &&
           verifier.EndTable();
  }
  CoinMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CoinMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CoinMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoinMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CoinMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coin(int64_t coin) {
    fbb_.AddElement<int64_t>(CoinMap::VT_COIN, coin, 0);
  }
  void add_summary(flatbuffers::Offset<SummaryItem> summary) {
    fbb_.AddOffset(CoinMap::VT_SUMMARY, summary);
  }
  explicit CoinMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CoinMapBuilder &operator=(const CoinMapBuilder &);
  flatbuffers::Offset<CoinMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CoinMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CoinMap> CreateCoinMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t coin = 0,
    flatbuffers::Offset<SummaryItem> summary = 0) {
  CoinMapBuilder builder_(_fbb);
  builder_.add_coin(coin);
  builder_.add_summary(summary);
  return builder_.Finish();
}

flatbuffers::Offset<CoinMap> CreateCoinMap(flatbuffers::FlatBufferBuilder &_fbb, const CoinMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SummaryT : public flatbuffers::NativeTable {
  typedef Summary TableType;
  std::vector<int8_t> addr;
  std::vector<std::unique_ptr<CoinMapT>> coin_maps;
  SummaryT() {
  }
};

struct Summary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SummaryT NativeTableType;
  enum {
    VT_ADDR = 4,
    VT_COIN_MAPS = 6
  };
  const flatbuffers::Vector<int8_t> *addr() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  flatbuffers::Vector<int8_t> *mutable_addr() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CoinMap>> *coin_maps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CoinMap>> *>(VT_COIN_MAPS);
  }
  flatbuffers::Vector<flatbuffers::Offset<CoinMap>> *mutable_coin_maps() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<CoinMap>> *>(VT_COIN_MAPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDR) &&
           verifier.Verify(addr()) &&
           VerifyOffset(verifier, VT_COIN_MAPS) &&
           verifier.Verify(coin_maps()) &&
           verifier.VerifyVectorOfTables(coin_maps()) &&
           verifier.EndTable();
  }
  SummaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SummaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Summary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SummaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SummaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addr(flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr) {
    fbb_.AddOffset(Summary::VT_ADDR, addr);
  }
  void add_coin_maps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CoinMap>>> coin_maps) {
    fbb_.AddOffset(Summary::VT_COIN_MAPS, coin_maps);
  }
  explicit SummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummaryBuilder &operator=(const SummaryBuilder &);
  flatbuffers::Offset<Summary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Summary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Summary> CreateSummary(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CoinMap>>> coin_maps = 0) {
  SummaryBuilder builder_(_fbb);
  builder_.add_coin_maps(coin_maps);
  builder_.add_addr(addr);
  return builder_.Finish();
}

inline flatbuffers::Offset<Summary> CreateSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *addr = nullptr,
    const std::vector<flatbuffers::Offset<CoinMap>> *coin_maps = nullptr) {
  return Devcash::fbs::CreateSummary(
      _fbb,
      addr ? _fbb.CreateVector<int8_t>(*addr) : 0,
      coin_maps ? _fbb.CreateVector<flatbuffers::Offset<CoinMap>>(*coin_maps) : 0);
}

flatbuffers::Offset<Summary> CreateSummary(flatbuffers::FlatBufferBuilder &_fbb, const SummaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateMapT : public flatbuffers::NativeTable {
  typedef StateMap TableType;
  int64_t coin;
  int64_t amount;
  StateMapT()
      : coin(0),
        amount(0) {
  }
};

struct StateMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateMapT NativeTableType;
  enum {
    VT_COIN = 4,
    VT_AMOUNT = 6
  };
  int64_t coin() const {
    return GetField<int64_t>(VT_COIN, 0);
  }
  bool mutate_coin(int64_t _coin) {
    return SetField<int64_t>(VT_COIN, _coin, 0);
  }
  int64_t amount() const {
    return GetField<int64_t>(VT_AMOUNT, 0);
  }
  bool mutate_amount(int64_t _amount) {
    return SetField<int64_t>(VT_AMOUNT, _amount, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_COIN) &&
           VerifyField<int64_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
  StateMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StateMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coin(int64_t coin) {
    fbb_.AddElement<int64_t>(StateMap::VT_COIN, coin, 0);
  }
  void add_amount(int64_t amount) {
    fbb_.AddElement<int64_t>(StateMap::VT_AMOUNT, amount, 0);
  }
  explicit StateMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateMapBuilder &operator=(const StateMapBuilder &);
  flatbuffers::Offset<StateMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StateMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateMap> CreateStateMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t coin = 0,
    int64_t amount = 0) {
  StateMapBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_coin(coin);
  return builder_.Finish();
}

flatbuffers::Offset<StateMap> CreateStateMap(flatbuffers::FlatBufferBuilder &_fbb, const StateMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChainStateT : public flatbuffers::NativeTable {
  typedef ChainState TableType;
  std::vector<int8_t> addr;
  std::vector<std::unique_ptr<StateMapT>> state_map;
  ChainStateT() {
  }
};

struct ChainState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChainStateT NativeTableType;
  enum {
    VT_ADDR = 4,
    VT_STATE_MAP = 6
  };
  const flatbuffers::Vector<int8_t> *addr() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  flatbuffers::Vector<int8_t> *mutable_addr() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ADDR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StateMap>> *state_map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StateMap>> *>(VT_STATE_MAP);
  }
  flatbuffers::Vector<flatbuffers::Offset<StateMap>> *mutable_state_map() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<StateMap>> *>(VT_STATE_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDR) &&
           verifier.Verify(addr()) &&
           VerifyOffset(verifier, VT_STATE_MAP) &&
           verifier.Verify(state_map()) &&
           verifier.VerifyVectorOfTables(state_map()) &&
           verifier.EndTable();
  }
  ChainStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChainStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ChainState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChainStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChainStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addr(flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr) {
    fbb_.AddOffset(ChainState::VT_ADDR, addr);
  }
  void add_state_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StateMap>>> state_map) {
    fbb_.AddOffset(ChainState::VT_STATE_MAP, state_map);
  }
  explicit ChainStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChainStateBuilder &operator=(const ChainStateBuilder &);
  flatbuffers::Offset<ChainState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChainState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChainState> CreateChainState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> addr = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StateMap>>> state_map = 0) {
  ChainStateBuilder builder_(_fbb);
  builder_.add_state_map(state_map);
  builder_.add_addr(addr);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChainState> CreateChainStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *addr = nullptr,
    const std::vector<flatbuffers::Offset<StateMap>> *state_map = nullptr) {
  return Devcash::fbs::CreateChainState(
      _fbb,
      addr ? _fbb.CreateVector<int8_t>(*addr) : 0,
      state_map ? _fbb.CreateVector<flatbuffers::Offset<StateMap>>(*state_map) : 0);
}

flatbuffers::Offset<ChainState> CreateChainState(flatbuffers::FlatBufferBuilder &_fbb, const ChainStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransactionSummaryBlockT : public flatbuffers::NativeTable {
  typedef TransactionSummaryBlock TableType;
  int8_t version_num;
  int64_t num_bytes;
  std::vector<std::unique_ptr<TransactionT>> transactions;
  std::vector<std::unique_ptr<SummaryT>> summaries;
  TransactionSummaryBlockT()
      : version_num(0),
        num_bytes(0) {
  }
};

struct TransactionSummaryBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransactionSummaryBlockT NativeTableType;
  enum {
    VT_VERSION_NUM = 4,
    VT_NUM_BYTES = 6,
    VT_TRANSACTIONS = 8,
    VT_SUMMARIES = 10
  };
  int8_t version_num() const {
    return GetField<int8_t>(VT_VERSION_NUM, 0);
  }
  bool mutate_version_num(int8_t _version_num) {
    return SetField<int8_t>(VT_VERSION_NUM, _version_num, 0);
  }
  int64_t num_bytes() const {
    return GetField<int64_t>(VT_NUM_BYTES, 0);
  }
  bool mutate_num_bytes(int64_t _num_bytes) {
    return SetField<int64_t>(VT_NUM_BYTES, _num_bytes, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transactions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Transaction>> *mutable_transactions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Summary>> *summaries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Summary>> *>(VT_SUMMARIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Summary>> *mutable_summaries() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Summary>> *>(VT_SUMMARIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VERSION_NUM) &&
           VerifyField<int64_t>(verifier, VT_NUM_BYTES) &&
           VerifyOffset(verifier, VT_TRANSACTIONS) &&
           verifier.Verify(transactions()) &&
           verifier.VerifyVectorOfTables(transactions()) &&
           VerifyOffset(verifier, VT_SUMMARIES) &&
           verifier.Verify(summaries()) &&
           verifier.VerifyVectorOfTables(summaries()) &&
           verifier.EndTable();
  }
  TransactionSummaryBlockT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransactionSummaryBlockT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransactionSummaryBlock> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionSummaryBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransactionSummaryBlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version_num(int8_t version_num) {
    fbb_.AddElement<int8_t>(TransactionSummaryBlock::VT_VERSION_NUM, version_num, 0);
  }
  void add_num_bytes(int64_t num_bytes) {
    fbb_.AddElement<int64_t>(TransactionSummaryBlock::VT_NUM_BYTES, num_bytes, 0);
  }
  void add_transactions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transactions) {
    fbb_.AddOffset(TransactionSummaryBlock::VT_TRANSACTIONS, transactions);
  }
  void add_summaries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Summary>>> summaries) {
    fbb_.AddOffset(TransactionSummaryBlock::VT_SUMMARIES, summaries);
  }
  explicit TransactionSummaryBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionSummaryBlockBuilder &operator=(const TransactionSummaryBlockBuilder &);
  flatbuffers::Offset<TransactionSummaryBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransactionSummaryBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransactionSummaryBlock> CreateTransactionSummaryBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t version_num = 0,
    int64_t num_bytes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transactions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Summary>>> summaries = 0) {
  TransactionSummaryBlockBuilder builder_(_fbb);
  builder_.add_num_bytes(num_bytes);
  builder_.add_summaries(summaries);
  builder_.add_transactions(transactions);
  builder_.add_version_num(version_num);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransactionSummaryBlock> CreateTransactionSummaryBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t version_num = 0,
    int64_t num_bytes = 0,
    const std::vector<flatbuffers::Offset<Transaction>> *transactions = nullptr,
    const std::vector<flatbuffers::Offset<Summary>> *summaries = nullptr) {
  return Devcash::fbs::CreateTransactionSummaryBlock(
      _fbb,
      version_num,
      num_bytes,
      transactions ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transactions) : 0,
      summaries ? _fbb.CreateVector<flatbuffers::Offset<Summary>>(*summaries) : 0);
}

flatbuffers::Offset<TransactionSummaryBlock> CreateTransactionSummaryBlock(flatbuffers::FlatBufferBuilder &_fbb, const TransactionSummaryBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TSVBlockT : public flatbuffers::NativeTable {
  typedef TSVBlock TableType;
  std::unique_ptr<int256> hash_prev_block;
  std::unique_ptr<int256> hash_merkle_root;
  std::vector<std::unique_ptr<ValidationT>> validations;
  int64_t time;
  std::unique_ptr<TransactionSummaryBlockT> ts_block;
  TSVBlockT()
      : time(0) {
  }
};

struct TSVBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TSVBlockT NativeTableType;
  enum {
    VT_HASH_PREV_BLOCK = 4,
    VT_HASH_MERKLE_ROOT = 6,
    VT_VALIDATIONS = 8,
    VT_TIME = 10,
    VT_TS_BLOCK = 12
  };
  const int256 *hash_prev_block() const {
    return GetStruct<const int256 *>(VT_HASH_PREV_BLOCK);
  }
  int256 *mutable_hash_prev_block() {
    return GetStruct<int256 *>(VT_HASH_PREV_BLOCK);
  }
  const int256 *hash_merkle_root() const {
    return GetStruct<const int256 *>(VT_HASH_MERKLE_ROOT);
  }
  int256 *mutable_hash_merkle_root() {
    return GetStruct<int256 *>(VT_HASH_MERKLE_ROOT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Validation>> *validations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Validation>> *>(VT_VALIDATIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Validation>> *mutable_validations() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Validation>> *>(VT_VALIDATIONS);
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool mutate_time(int64_t _time) {
    return SetField<int64_t>(VT_TIME, _time, 0);
  }
  const TransactionSummaryBlock *ts_block() const {
    return GetPointer<const TransactionSummaryBlock *>(VT_TS_BLOCK);
  }
  TransactionSummaryBlock *mutable_ts_block() {
    return GetPointer<TransactionSummaryBlock *>(VT_TS_BLOCK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int256>(verifier, VT_HASH_PREV_BLOCK) &&
           VerifyField<int256>(verifier, VT_HASH_MERKLE_ROOT) &&
           VerifyOffset(verifier, VT_VALIDATIONS) &&
           verifier.Verify(validations()) &&
           verifier.VerifyVectorOfTables(validations()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_TS_BLOCK) &&
           verifier.VerifyTable(ts_block()) &&
           verifier.EndTable();
  }
  TSVBlockT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TSVBlockT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TSVBlock> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSVBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TSVBlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash_prev_block(const int256 *hash_prev_block) {
    fbb_.AddStruct(TSVBlock::VT_HASH_PREV_BLOCK, hash_prev_block);
  }
  void add_hash_merkle_root(const int256 *hash_merkle_root) {
    fbb_.AddStruct(TSVBlock::VT_HASH_MERKLE_ROOT, hash_merkle_root);
  }
  void add_validations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Validation>>> validations) {
    fbb_.AddOffset(TSVBlock::VT_VALIDATIONS, validations);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(TSVBlock::VT_TIME, time, 0);
  }
  void add_ts_block(flatbuffers::Offset<TransactionSummaryBlock> ts_block) {
    fbb_.AddOffset(TSVBlock::VT_TS_BLOCK, ts_block);
  }
  explicit TSVBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TSVBlockBuilder &operator=(const TSVBlockBuilder &);
  flatbuffers::Offset<TSVBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TSVBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<TSVBlock> CreateTSVBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    const int256 *hash_prev_block = 0,
    const int256 *hash_merkle_root = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Validation>>> validations = 0,
    int64_t time = 0,
    flatbuffers::Offset<TransactionSummaryBlock> ts_block = 0) {
  TSVBlockBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_ts_block(ts_block);
  builder_.add_validations(validations);
  builder_.add_hash_merkle_root(hash_merkle_root);
  builder_.add_hash_prev_block(hash_prev_block);
  return builder_.Finish();
}

inline flatbuffers::Offset<TSVBlock> CreateTSVBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const int256 *hash_prev_block = 0,
    const int256 *hash_merkle_root = 0,
    const std::vector<flatbuffers::Offset<Validation>> *validations = nullptr,
    int64_t time = 0,
    flatbuffers::Offset<TransactionSummaryBlock> ts_block = 0) {
  return Devcash::fbs::CreateTSVBlock(
      _fbb,
      hash_prev_block,
      hash_merkle_root,
      validations ? _fbb.CreateVector<flatbuffers::Offset<Validation>>(*validations) : 0,
      time,
      ts_block);
}

flatbuffers::Offset<TSVBlock> CreateTSVBlock(flatbuffers::FlatBufferBuilder &_fbb, const TSVBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FinalBlockT : public flatbuffers::NativeTable {
  typedef FinalBlock TableType;
  std::unique_ptr<TSVBlockT> tsv_block;
  FinalBlockT() {
  }
};

struct FinalBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FinalBlockT NativeTableType;
  enum {
    VT_TSV_BLOCK = 4
  };
  const TSVBlock *tsv_block() const {
    return GetPointer<const TSVBlock *>(VT_TSV_BLOCK);
  }
  TSVBlock *mutable_tsv_block() {
    return GetPointer<TSVBlock *>(VT_TSV_BLOCK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TSV_BLOCK) &&
           verifier.VerifyTable(tsv_block()) &&
           verifier.EndTable();
  }
  FinalBlockT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FinalBlockT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FinalBlock> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FinalBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FinalBlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tsv_block(flatbuffers::Offset<TSVBlock> tsv_block) {
    fbb_.AddOffset(FinalBlock::VT_TSV_BLOCK, tsv_block);
  }
  explicit FinalBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FinalBlockBuilder &operator=(const FinalBlockBuilder &);
  flatbuffers::Offset<FinalBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FinalBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<FinalBlock> CreateFinalBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TSVBlock> tsv_block = 0) {
  FinalBlockBuilder builder_(_fbb);
  builder_.add_tsv_block(tsv_block);
  return builder_.Finish();
}

flatbuffers::Offset<FinalBlock> CreateFinalBlock(flatbuffers::FlatBufferBuilder &_fbb, const FinalBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalBlockT : public flatbuffers::NativeTable {
  typedef ProposalBlock TableType;
  std::unique_ptr<TSVBlockT> tsv_block_;
  ProposalBlockT() {
  }
};

struct ProposalBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalBlockT NativeTableType;
  enum {
    VT_TSV_BLOCK_ = 4
  };
  const TSVBlock *tsv_block_() const {
    return GetPointer<const TSVBlock *>(VT_TSV_BLOCK_);
  }
  TSVBlock *mutable_tsv_block_() {
    return GetPointer<TSVBlock *>(VT_TSV_BLOCK_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TSV_BLOCK_) &&
           verifier.VerifyTable(tsv_block_()) &&
           verifier.EndTable();
  }
  ProposalBlockT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalBlockT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProposalBlock> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalBlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tsv_block_(flatbuffers::Offset<TSVBlock> tsv_block_) {
    fbb_.AddOffset(ProposalBlock::VT_TSV_BLOCK_, tsv_block_);
  }
  explicit ProposalBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalBlockBuilder &operator=(const ProposalBlockBuilder &);
  flatbuffers::Offset<ProposalBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProposalBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalBlock> CreateProposalBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TSVBlock> tsv_block_ = 0) {
  ProposalBlockBuilder builder_(_fbb);
  builder_.add_tsv_block_(tsv_block_);
  return builder_.Finish();
}

flatbuffers::Offset<ProposalBlock> CreateProposalBlock(flatbuffers::FlatBufferBuilder &_fbb, const ProposalBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpcomingBlockT : public flatbuffers::NativeTable {
  typedef UpcomingBlock TableType;
  std::unique_ptr<TransactionSummaryBlockT> ts_block;
  UpcomingBlockT() {
  }
};

struct UpcomingBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpcomingBlockT NativeTableType;
  enum {
    VT_TS_BLOCK = 4
  };
  const TransactionSummaryBlock *ts_block() const {
    return GetPointer<const TransactionSummaryBlock *>(VT_TS_BLOCK);
  }
  TransactionSummaryBlock *mutable_ts_block() {
    return GetPointer<TransactionSummaryBlock *>(VT_TS_BLOCK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TS_BLOCK) &&
           verifier.VerifyTable(ts_block()) &&
           verifier.EndTable();
  }
  UpcomingBlockT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpcomingBlockT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UpcomingBlock> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpcomingBlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ts_block(flatbuffers::Offset<TransactionSummaryBlock> ts_block) {
    fbb_.AddOffset(UpcomingBlock::VT_TS_BLOCK, ts_block);
  }
  explicit UpcomingBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcomingBlockBuilder &operator=(const UpcomingBlockBuilder &);
  flatbuffers::Offset<UpcomingBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcomingBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcomingBlock> CreateUpcomingBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TransactionSummaryBlock> ts_block = 0) {
  UpcomingBlockBuilder builder_(_fbb);
  builder_.add_ts_block(ts_block);
  return builder_.Finish();
}

flatbuffers::Offset<UpcomingBlock> CreateUpcomingBlock(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransactionAnnouncementT : public flatbuffers::NativeTable {
  typedef TransactionAnnouncement TableType;
  std::vector<std::unique_ptr<TransactionT>> transactions;
  TransactionAnnouncementT() {
  }
};

struct TransactionAnnouncement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransactionAnnouncementT NativeTableType;
  enum {
    VT_TRANSACTIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transactions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Transaction>> *mutable_transactions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRANSACTIONS) &&
           verifier.Verify(transactions()) &&
           verifier.VerifyVectorOfTables(transactions()) &&
           verifier.EndTable();
  }
  TransactionAnnouncementT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransactionAnnouncementT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransactionAnnouncement> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionAnnouncementT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransactionAnnouncementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transactions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transactions) {
    fbb_.AddOffset(TransactionAnnouncement::VT_TRANSACTIONS, transactions);
  }
  explicit TransactionAnnouncementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionAnnouncementBuilder &operator=(const TransactionAnnouncementBuilder &);
  flatbuffers::Offset<TransactionAnnouncement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransactionAnnouncement>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransactionAnnouncement> CreateTransactionAnnouncement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transactions = 0) {
  TransactionAnnouncementBuilder builder_(_fbb);
  builder_.add_transactions(transactions);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransactionAnnouncement> CreateTransactionAnnouncementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transactions = nullptr) {
  return Devcash::fbs::CreateTransactionAnnouncement(
      _fbb,
      transactions ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transactions) : 0);
}

flatbuffers::Offset<TransactionAnnouncement> CreateTransactionAnnouncement(flatbuffers::FlatBufferBuilder &_fbb, const TransactionAnnouncementT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpcomingChainT : public flatbuffers::NativeTable {
  typedef UpcomingChain TableType;
  std::vector<std::unique_ptr<UpcomingBlockT>> chain;
  std::unique_ptr<ChainStateT> state;
  UpcomingChainT() {
  }
};

struct UpcomingChain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpcomingChainT NativeTableType;
  enum {
    VT_CHAIN = 4,
    VT_STATE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<UpcomingBlock>> *chain() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UpcomingBlock>> *>(VT_CHAIN);
  }
  flatbuffers::Vector<flatbuffers::Offset<UpcomingBlock>> *mutable_chain() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UpcomingBlock>> *>(VT_CHAIN);
  }
  const ChainState *state() const {
    return GetPointer<const ChainState *>(VT_STATE);
  }
  ChainState *mutable_state() {
    return GetPointer<ChainState *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHAIN) &&
           verifier.Verify(chain()) &&
           verifier.VerifyVectorOfTables(chain()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
  UpcomingChainT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpcomingChainT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UpcomingChain> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingChainT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpcomingChainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chain(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UpcomingBlock>>> chain) {
    fbb_.AddOffset(UpcomingChain::VT_CHAIN, chain);
  }
  void add_state(flatbuffers::Offset<ChainState> state) {
    fbb_.AddOffset(UpcomingChain::VT_STATE, state);
  }
  explicit UpcomingChainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcomingChainBuilder &operator=(const UpcomingChainBuilder &);
  flatbuffers::Offset<UpcomingChain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcomingChain>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcomingChain> CreateUpcomingChain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UpcomingBlock>>> chain = 0,
    flatbuffers::Offset<ChainState> state = 0) {
  UpcomingChainBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_chain(chain);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpcomingChain> CreateUpcomingChainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UpcomingBlock>> *chain = nullptr,
    flatbuffers::Offset<ChainState> state = 0) {
  return Devcash::fbs::CreateUpcomingChain(
      _fbb,
      chain ? _fbb.CreateVector<flatbuffers::Offset<UpcomingBlock>>(*chain) : 0,
      state);
}

flatbuffers::Offset<UpcomingChain> CreateUpcomingChain(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingChainT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalChainT : public flatbuffers::NativeTable {
  typedef ProposalChain TableType;
  std::vector<std::unique_ptr<ProposalBlockT>> chain;
  std::unique_ptr<ChainStateT> state;
  ProposalChainT() {
  }
};

struct ProposalChain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalChainT NativeTableType;
  enum {
    VT_CHAIN = 4,
    VT_STATE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<ProposalBlock>> *chain() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProposalBlock>> *>(VT_CHAIN);
  }
  flatbuffers::Vector<flatbuffers::Offset<ProposalBlock>> *mutable_chain() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ProposalBlock>> *>(VT_CHAIN);
  }
  const ChainState *state() const {
    return GetPointer<const ChainState *>(VT_STATE);
  }
  ChainState *mutable_state() {
    return GetPointer<ChainState *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHAIN) &&
           verifier.Verify(chain()) &&
           verifier.VerifyVectorOfTables(chain()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
  ProposalChainT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalChainT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProposalChain> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalChainT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalChainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chain(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProposalBlock>>> chain) {
    fbb_.AddOffset(ProposalChain::VT_CHAIN, chain);
  }
  void add_state(flatbuffers::Offset<ChainState> state) {
    fbb_.AddOffset(ProposalChain::VT_STATE, state);
  }
  explicit ProposalChainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalChainBuilder &operator=(const ProposalChainBuilder &);
  flatbuffers::Offset<ProposalChain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProposalChain>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalChain> CreateProposalChain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProposalBlock>>> chain = 0,
    flatbuffers::Offset<ChainState> state = 0) {
  ProposalChainBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_chain(chain);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProposalChain> CreateProposalChainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ProposalBlock>> *chain = nullptr,
    flatbuffers::Offset<ChainState> state = 0) {
  return Devcash::fbs::CreateProposalChain(
      _fbb,
      chain ? _fbb.CreateVector<flatbuffers::Offset<ProposalBlock>>(*chain) : 0,
      state);
}

flatbuffers::Offset<ProposalChain> CreateProposalChain(flatbuffers::FlatBufferBuilder &_fbb, const ProposalChainT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FinalChainT : public flatbuffers::NativeTable {
  typedef FinalChain TableType;
  std::vector<std::unique_ptr<FinalBlockT>> chain;
  std::unique_ptr<ChainStateT> state;
  FinalChainT() {
  }
};

struct FinalChain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FinalChainT NativeTableType;
  enum {
    VT_CHAIN = 4,
    VT_STATE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FinalBlock>> *chain() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FinalBlock>> *>(VT_CHAIN);
  }
  flatbuffers::Vector<flatbuffers::Offset<FinalBlock>> *mutable_chain() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<FinalBlock>> *>(VT_CHAIN);
  }
  const ChainState *state() const {
    return GetPointer<const ChainState *>(VT_STATE);
  }
  ChainState *mutable_state() {
    return GetPointer<ChainState *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHAIN) &&
           verifier.Verify(chain()) &&
           verifier.VerifyVectorOfTables(chain()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
  FinalChainT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FinalChainT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FinalChain> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FinalChainT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FinalChainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chain(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FinalBlock>>> chain) {
    fbb_.AddOffset(FinalChain::VT_CHAIN, chain);
  }
  void add_state(flatbuffers::Offset<ChainState> state) {
    fbb_.AddOffset(FinalChain::VT_STATE, state);
  }
  explicit FinalChainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FinalChainBuilder &operator=(const FinalChainBuilder &);
  flatbuffers::Offset<FinalChain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FinalChain>(end);
    return o;
  }
};

inline flatbuffers::Offset<FinalChain> CreateFinalChain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FinalBlock>>> chain = 0,
    flatbuffers::Offset<ChainState> state = 0) {
  FinalChainBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_chain(chain);
  return builder_.Finish();
}

inline flatbuffers::Offset<FinalChain> CreateFinalChainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FinalBlock>> *chain = nullptr,
    flatbuffers::Offset<ChainState> state = 0) {
  return Devcash::fbs::CreateFinalChain(
      _fbb,
      chain ? _fbb.CreateVector<flatbuffers::Offset<FinalBlock>>(*chain) : 0,
      state);
}

flatbuffers::Offset<FinalChain> CreateFinalChain(flatbuffers::FlatBufferBuilder &_fbb, const FinalChainT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TransferT *Transfer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransferT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transfer::UnPackTo(TransferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = addr(); if (_e) { _o->addr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->addr[_i] = _e->Get(_i); } } };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = coin_index(); _o->coin_index = _e; };
  { auto _e = delay(); _o->delay = _e; };
}

inline flatbuffers::Offset<Transfer> Transfer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransferT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransfer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transfer> CreateTransfer(flatbuffers::FlatBufferBuilder &_fbb, const TransferT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransferT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _addr = _o->addr.size() ? _fbb.CreateVector(_o->addr) : 0;
  auto _amount = _o->amount;
  auto _coin_index = _o->coin_index;
  auto _delay = _o->delay;
  return Devcash::fbs::CreateTransfer(
      _fbb,
      _addr,
      _amount,
      _coin_index,
      _delay);
}

inline TransactionT *Transaction::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransactionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transaction::UnPackTo(TransactionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = xfers(); if (_e) { _o->xfers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->xfers[_i] = std::unique_ptr<TransferT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = nonce(); if (_e) { _o->nonce.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nonce[_i] = _e->Get(_i); } } };
  { auto _e = sig(); if (_e) { _o->sig.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sig[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Transaction> Transaction::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransaction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransactionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _xfers = _o->xfers.size() ? _fbb.CreateVector<flatbuffers::Offset<Transfer>> (_o->xfers.size(), [](size_t i, _VectorArgs *__va) { return CreateTransfer(*__va->__fbb, __va->__o->xfers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nonce = _o->nonce.size() ? _fbb.CreateVector(_o->nonce) : 0;
  auto _sig = _o->sig.size() ? _fbb.CreateVector(_o->sig) : 0;
  return Devcash::fbs::CreateTransaction(
      _fbb,
      _xfers,
      _nonce,
      _sig);
}

inline ValidationMapT *ValidationMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ValidationMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ValidationMap::UnPackTo(ValidationMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = addr(); if (_e) { _o->addr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->addr[_i] = _e->Get(_i); } } };
  { auto _e = sig(); if (_e) { _o->sig.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sig[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<ValidationMap> ValidationMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ValidationMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValidationMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ValidationMap> CreateValidationMap(flatbuffers::FlatBufferBuilder &_fbb, const ValidationMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ValidationMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _addr = _o->addr.size() ? _fbb.CreateVector(_o->addr) : 0;
  auto _sig = _o->sig.size() ? _fbb.CreateVector(_o->sig) : 0;
  return Devcash::fbs::CreateValidationMap(
      _fbb,
      _addr,
      _sig);
}

inline ValidationT *Validation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ValidationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Validation::UnPackTo(ValidationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = summary_map(); if (_e) { _o->summary_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->summary_map[_i] = std::unique_ptr<ValidationMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Validation> Validation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ValidationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValidation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Validation> CreateValidation(flatbuffers::FlatBufferBuilder &_fbb, const ValidationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ValidationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _summary_map = _o->summary_map.size() ? _fbb.CreateVector<flatbuffers::Offset<ValidationMap>> (_o->summary_map.size(), [](size_t i, _VectorArgs *__va) { return CreateValidationMap(*__va->__fbb, __va->__o->summary_map[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Devcash::fbs::CreateValidation(
      _fbb,
      _summary_map);
}

inline SummaryItemT *SummaryItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SummaryItemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SummaryItem::UnPackTo(SummaryItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = delay(); _o->delay = _e; };
  { auto _e = delta(); _o->delta = _e; };
}

inline flatbuffers::Offset<SummaryItem> SummaryItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SummaryItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSummaryItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SummaryItem> CreateSummaryItem(flatbuffers::FlatBufferBuilder &_fbb, const SummaryItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SummaryItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _delay = _o->delay;
  auto _delta = _o->delta;
  return Devcash::fbs::CreateSummaryItem(
      _fbb,
      _delay,
      _delta);
}

inline CoinMapT *CoinMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CoinMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CoinMap::UnPackTo(CoinMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coin(); _o->coin = _e; };
  { auto _e = summary(); if (_e) _o->summary = std::unique_ptr<SummaryItemT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CoinMap> CoinMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoinMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCoinMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CoinMap> CreateCoinMap(flatbuffers::FlatBufferBuilder &_fbb, const CoinMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CoinMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coin = _o->coin;
  auto _summary = _o->summary ? CreateSummaryItem(_fbb, _o->summary.get(), _rehasher) : 0;
  return Devcash::fbs::CreateCoinMap(
      _fbb,
      _coin,
      _summary);
}

inline SummaryT *Summary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SummaryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Summary::UnPackTo(SummaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = addr(); if (_e) { _o->addr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->addr[_i] = _e->Get(_i); } } };
  { auto _e = coin_maps(); if (_e) { _o->coin_maps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coin_maps[_i] = std::unique_ptr<CoinMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Summary> Summary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SummaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSummary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Summary> CreateSummary(flatbuffers::FlatBufferBuilder &_fbb, const SummaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SummaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _addr = _o->addr.size() ? _fbb.CreateVector(_o->addr) : 0;
  auto _coin_maps = _o->coin_maps.size() ? _fbb.CreateVector<flatbuffers::Offset<CoinMap>> (_o->coin_maps.size(), [](size_t i, _VectorArgs *__va) { return CreateCoinMap(*__va->__fbb, __va->__o->coin_maps[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Devcash::fbs::CreateSummary(
      _fbb,
      _addr,
      _coin_maps);
}

inline StateMapT *StateMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StateMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StateMap::UnPackTo(StateMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coin(); _o->coin = _e; };
  { auto _e = amount(); _o->amount = _e; };
}

inline flatbuffers::Offset<StateMap> StateMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStateMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StateMap> CreateStateMap(flatbuffers::FlatBufferBuilder &_fbb, const StateMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StateMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coin = _o->coin;
  auto _amount = _o->amount;
  return Devcash::fbs::CreateStateMap(
      _fbb,
      _coin,
      _amount);
}

inline ChainStateT *ChainState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ChainStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ChainState::UnPackTo(ChainStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = addr(); if (_e) { _o->addr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->addr[_i] = _e->Get(_i); } } };
  { auto _e = state_map(); if (_e) { _o->state_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->state_map[_i] = std::unique_ptr<StateMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ChainState> ChainState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChainStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChainState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ChainState> CreateChainState(flatbuffers::FlatBufferBuilder &_fbb, const ChainStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ChainStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _addr = _o->addr.size() ? _fbb.CreateVector(_o->addr) : 0;
  auto _state_map = _o->state_map.size() ? _fbb.CreateVector<flatbuffers::Offset<StateMap>> (_o->state_map.size(), [](size_t i, _VectorArgs *__va) { return CreateStateMap(*__va->__fbb, __va->__o->state_map[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Devcash::fbs::CreateChainState(
      _fbb,
      _addr,
      _state_map);
}

inline TransactionSummaryBlockT *TransactionSummaryBlock::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransactionSummaryBlockT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TransactionSummaryBlock::UnPackTo(TransactionSummaryBlockT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version_num(); _o->version_num = _e; };
  { auto _e = num_bytes(); _o->num_bytes = _e; };
  { auto _e = transactions(); if (_e) { _o->transactions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transactions[_i] = std::unique_ptr<TransactionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = summaries(); if (_e) { _o->summaries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->summaries[_i] = std::unique_ptr<SummaryT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TransactionSummaryBlock> TransactionSummaryBlock::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionSummaryBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransactionSummaryBlock(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransactionSummaryBlock> CreateTransactionSummaryBlock(flatbuffers::FlatBufferBuilder &_fbb, const TransactionSummaryBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransactionSummaryBlockT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version_num = _o->version_num;
  auto _num_bytes = _o->num_bytes;
  auto _transactions = _o->transactions.size() ? _fbb.CreateVector<flatbuffers::Offset<Transaction>> (_o->transactions.size(), [](size_t i, _VectorArgs *__va) { return CreateTransaction(*__va->__fbb, __va->__o->transactions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _summaries = _o->summaries.size() ? _fbb.CreateVector<flatbuffers::Offset<Summary>> (_o->summaries.size(), [](size_t i, _VectorArgs *__va) { return CreateSummary(*__va->__fbb, __va->__o->summaries[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Devcash::fbs::CreateTransactionSummaryBlock(
      _fbb,
      _version_num,
      _num_bytes,
      _transactions,
      _summaries);
}

inline TSVBlockT *TSVBlock::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TSVBlockT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TSVBlock::UnPackTo(TSVBlockT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash_prev_block(); if (_e) _o->hash_prev_block = std::unique_ptr<int256>(new int256(*_e)); };
  { auto _e = hash_merkle_root(); if (_e) _o->hash_merkle_root = std::unique_ptr<int256>(new int256(*_e)); };
  { auto _e = validations(); if (_e) { _o->validations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->validations[_i] = std::unique_ptr<ValidationT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = time(); _o->time = _e; };
  { auto _e = ts_block(); if (_e) _o->ts_block = std::unique_ptr<TransactionSummaryBlockT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TSVBlock> TSVBlock::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSVBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTSVBlock(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TSVBlock> CreateTSVBlock(flatbuffers::FlatBufferBuilder &_fbb, const TSVBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TSVBlockT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash_prev_block = _o->hash_prev_block ? _o->hash_prev_block.get() : 0;
  auto _hash_merkle_root = _o->hash_merkle_root ? _o->hash_merkle_root.get() : 0;
  auto _validations = _o->validations.size() ? _fbb.CreateVector<flatbuffers::Offset<Validation>> (_o->validations.size(), [](size_t i, _VectorArgs *__va) { return CreateValidation(*__va->__fbb, __va->__o->validations[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _time = _o->time;
  auto _ts_block = _o->ts_block ? CreateTransactionSummaryBlock(_fbb, _o->ts_block.get(), _rehasher) : 0;
  return Devcash::fbs::CreateTSVBlock(
      _fbb,
      _hash_prev_block,
      _hash_merkle_root,
      _validations,
      _time,
      _ts_block);
}

inline FinalBlockT *FinalBlock::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FinalBlockT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FinalBlock::UnPackTo(FinalBlockT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tsv_block(); if (_e) _o->tsv_block = std::unique_ptr<TSVBlockT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<FinalBlock> FinalBlock::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FinalBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFinalBlock(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FinalBlock> CreateFinalBlock(flatbuffers::FlatBufferBuilder &_fbb, const FinalBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FinalBlockT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tsv_block = _o->tsv_block ? CreateTSVBlock(_fbb, _o->tsv_block.get(), _rehasher) : 0;
  return Devcash::fbs::CreateFinalBlock(
      _fbb,
      _tsv_block);
}

inline ProposalBlockT *ProposalBlock::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProposalBlockT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProposalBlock::UnPackTo(ProposalBlockT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tsv_block_(); if (_e) _o->tsv_block_ = std::unique_ptr<TSVBlockT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ProposalBlock> ProposalBlock::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposalBlock(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProposalBlock> CreateProposalBlock(flatbuffers::FlatBufferBuilder &_fbb, const ProposalBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalBlockT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tsv_block_ = _o->tsv_block_ ? CreateTSVBlock(_fbb, _o->tsv_block_.get(), _rehasher) : 0;
  return Devcash::fbs::CreateProposalBlock(
      _fbb,
      _tsv_block_);
}

inline UpcomingBlockT *UpcomingBlock::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UpcomingBlockT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UpcomingBlock::UnPackTo(UpcomingBlockT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ts_block(); if (_e) _o->ts_block = std::unique_ptr<TransactionSummaryBlockT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<UpcomingBlock> UpcomingBlock::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingBlockT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpcomingBlock(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UpcomingBlock> CreateUpcomingBlock(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UpcomingBlockT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ts_block = _o->ts_block ? CreateTransactionSummaryBlock(_fbb, _o->ts_block.get(), _rehasher) : 0;
  return Devcash::fbs::CreateUpcomingBlock(
      _fbb,
      _ts_block);
}

inline TransactionAnnouncementT *TransactionAnnouncement::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransactionAnnouncementT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TransactionAnnouncement::UnPackTo(TransactionAnnouncementT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transactions(); if (_e) { _o->transactions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transactions[_i] = std::unique_ptr<TransactionT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TransactionAnnouncement> TransactionAnnouncement::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionAnnouncementT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransactionAnnouncement(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransactionAnnouncement> CreateTransactionAnnouncement(flatbuffers::FlatBufferBuilder &_fbb, const TransactionAnnouncementT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransactionAnnouncementT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transactions = _o->transactions.size() ? _fbb.CreateVector<flatbuffers::Offset<Transaction>> (_o->transactions.size(), [](size_t i, _VectorArgs *__va) { return CreateTransaction(*__va->__fbb, __va->__o->transactions[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Devcash::fbs::CreateTransactionAnnouncement(
      _fbb,
      _transactions);
}

inline UpcomingChainT *UpcomingChain::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UpcomingChainT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UpcomingChain::UnPackTo(UpcomingChainT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chain(); if (_e) { _o->chain.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chain[_i] = std::unique_ptr<UpcomingBlockT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = state(); if (_e) _o->state = std::unique_ptr<ChainStateT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<UpcomingChain> UpcomingChain::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingChainT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpcomingChain(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UpcomingChain> CreateUpcomingChain(flatbuffers::FlatBufferBuilder &_fbb, const UpcomingChainT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UpcomingChainT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chain = _o->chain.size() ? _fbb.CreateVector<flatbuffers::Offset<UpcomingBlock>> (_o->chain.size(), [](size_t i, _VectorArgs *__va) { return CreateUpcomingBlock(*__va->__fbb, __va->__o->chain[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _state = _o->state ? CreateChainState(_fbb, _o->state.get(), _rehasher) : 0;
  return Devcash::fbs::CreateUpcomingChain(
      _fbb,
      _chain,
      _state);
}

inline ProposalChainT *ProposalChain::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProposalChainT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProposalChain::UnPackTo(ProposalChainT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chain(); if (_e) { _o->chain.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chain[_i] = std::unique_ptr<ProposalBlockT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = state(); if (_e) _o->state = std::unique_ptr<ChainStateT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ProposalChain> ProposalChain::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalChainT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposalChain(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProposalChain> CreateProposalChain(flatbuffers::FlatBufferBuilder &_fbb, const ProposalChainT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalChainT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chain = _o->chain.size() ? _fbb.CreateVector<flatbuffers::Offset<ProposalBlock>> (_o->chain.size(), [](size_t i, _VectorArgs *__va) { return CreateProposalBlock(*__va->__fbb, __va->__o->chain[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _state = _o->state ? CreateChainState(_fbb, _o->state.get(), _rehasher) : 0;
  return Devcash::fbs::CreateProposalChain(
      _fbb,
      _chain,
      _state);
}

inline FinalChainT *FinalChain::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FinalChainT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FinalChain::UnPackTo(FinalChainT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chain(); if (_e) { _o->chain.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chain[_i] = std::unique_ptr<FinalBlockT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = state(); if (_e) _o->state = std::unique_ptr<ChainStateT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<FinalChain> FinalChain::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FinalChainT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFinalChain(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FinalChain> CreateFinalChain(flatbuffers::FlatBufferBuilder &_fbb, const FinalChainT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FinalChainT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chain = _o->chain.size() ? _fbb.CreateVector<flatbuffers::Offset<FinalBlock>> (_o->chain.size(), [](size_t i, _VectorArgs *__va) { return CreateFinalBlock(*__va->__fbb, __va->__o->chain[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _state = _o->state ? CreateChainState(_fbb, _o->state.get(), _rehasher) : 0;
  return Devcash::fbs::CreateFinalChain(
      _fbb,
      _chain,
      _state);
}

inline const Devcash::fbs::FinalBlock *GetFinalBlock(const void *buf) {
  return flatbuffers::GetRoot<Devcash::fbs::FinalBlock>(buf);
}

inline const Devcash::fbs::FinalBlock *GetSizePrefixedFinalBlock(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Devcash::fbs::FinalBlock>(buf);
}

inline FinalBlock *GetMutableFinalBlock(void *buf) {
  return flatbuffers::GetMutableRoot<FinalBlock>(buf);
}

inline bool VerifyFinalBlockBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Devcash::fbs::FinalBlock>(nullptr);
}

inline bool VerifySizePrefixedFinalBlockBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Devcash::fbs::FinalBlock>(nullptr);
}

inline void FinishFinalBlockBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Devcash::fbs::FinalBlock> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFinalBlockBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Devcash::fbs::FinalBlock> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<FinalBlockT> UnPackFinalBlock(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<FinalBlockT>(GetFinalBlock(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace Devcash

#endif  // FLATBUFFERS_GENERATED_DEVCASHPRIMITIVES_DEVCASH_FBS_H_
